# Problem Set 2
## Concept Questions
1. The contexts help to scope the uniqueness of the strings, so the nonces do not necessarily have to be unique throughout the app but only within the given context. In the URL shortening app, the context will likely end up being the base URL/domain name, since they can be user-specified.
2. It stores used strings to ensure that no nonce is reused within the context. The size of the set of used strings for a context = counter for that context.
3. Advantage: more memorable shortenings make the app more user-friendly because it is easier for them to recall and share the short URL (by typing or verbally). Disadvantage: it reduces the size of the overall set of strings that could possibly be generated, so if there are too many URLs being shortened, there may not be any available unused strings for a new short URL and collisions may happen more frequently.

To realize this idea, we can add `a dictionary set of Strings` to the state and modify the effect of the `generate` action: returns a nonce that is not already used by this context, chosen from the dictionary.

## Synchronization Questions
1. The generate sync only needs to produce a nonce scoped to the context of the base URL; this process is not linked to the target URL. Meanwhile, register needs the target URL in order to create a mapping between the target URL and the nonce generated by the first sync.
2. There are cases where the argument or result name does not match their variable names, and in such cases the argument or result name should not be changed to match the variable name because the original names have some meaning in the action that was defined previously. Keeping the names also helps to understand the purpose of a variable being used in a certain place; for example, `nonce` could be used for many different purposes in general but having it assigned to `shortUrlSuffix` makes its purpose as a URL-shortening string clear.
3. The setExpiry action doesn't need to use any of the information from the request action; it relies solely on the completion of the registration action and the full short URL from the registration action.
4. Pass the string "bit.ly" as inputs instead of using the variable shortUrlBase, in the request/generate/register actions.
5. 
**sync** deleteExpiredResource\
**when** ExpiringResource.expireResource(): (resource)\
**then** UrlShortening.delete(shortUrl: resource)

## Extension
1.
**concept** UrlOwnership [User]\
**purpose** associate short URLs with the users that created them, and allow verification of this association\
**principle** after recording a short URL and its owner, getOwner will return the owner of the given short URL\
**state** \
&nbsp;&nbsp;a set of Pairs with\
&nbsp;&nbsp;&nbsp;&nbsp;an owner User\
&nbsp;&nbsp;&nbsp;&nbsp;a shortUrl String\
**actions**\
&nbsp;&nbsp;recordOwner (user: User, shortUrl: String): (void)\
&nbsp;&nbsp;&nbsp;&nbsp;**requires** no Pair exists with the given shortUrl\
&nbsp;&nbsp;&nbsp;&nbsp;**effect** saves a new Pair where the owner is the given user and the shortUrl is the given shortUrl\
&nbsp;&nbsp;getOwner (shortUrl: String): (owner: User)\
&nbsp;&nbsp;&nbsp;&nbsp;**requires** exactly one Pair exists with the given shortUrl\
&nbsp;&nbsp;&nbsp;&nbsp;**effect** returns the owner associated with the given shortUrl via the required pair

**concept** Analytics\
**purpose** count the number of times a short URL has been accessed\
**principle** count increments every time a short URL is used\
**state** \
&nbsp;&nbsp;a set of Records with\
&nbsp;&nbsp;&nbsp;&nbsp;a count Number\
&nbsp;&nbsp;&nbsp;&nbsp;a shortUrl String\
**actions**\
&nbsp;&nbsp;incrementCount (shortUrl: String): (void)\
&nbsp;&nbsp;&nbsp;&nbsp;**effect** if there exists a Record with the given shortUrl, increases the count of this record by 1; otherwise, creates a new Record with count=1 and the given shortUrl\
&nbsp;&nbsp;getCount (shortUrl: String, user: User): (count: Number)\
&nbsp;&nbsp;&nbsp;&nbsp;**requires** UrlOwnership.getOwner(shortUrl)=user\
&nbsp;&nbsp;&nbsp;&nbsp;**effect** if there exists a Record with the given shortUrl, returns the count of this record; otherwise, returns 0

2.
**sync** recordOwnerOnRegister\
**when**\
&nbsp;&nbsp;Request.shortenUrl (user)\
&nbsp;&nbsp;UrlShortening.register(): (shortUrl)\
**then** UrlOwnership.recordOwner(user, shortUrl)

**sync** incrementCountOnLookup\
**when** UrlShortening.lookup(shortUrl)\
**then** Analytics.incrementCount(shortUrl)

**sync** getAnalytics\
**when** Request.getAnalytics(user, shortUrl)\
**then** Analytics.getCount(shortUrl, user): (count)\

3.
    - Allowing users to choose their own short URLs: a new optional suffix String argument should be added to Request.shortenUrl, and we should also add a new sync that directly calls UrlShortening.register without calling NonceGeneration.generate if the suffix is specified. 
    - Using the “word as nonce” strategy to generate more memorable short URLs: create a new concept WordNonceGeneration for generating word nonces that uses a dictionary of words instead of arbitrary strings, and swap the call to NonceGeneration.generate for WordNonceGeneration.generate.
    - Including the target URL in analytics, so that lookups of different short URLs can be grouped together when they refer to the same target URL: add a new concept TargetAnalytics whcih is similar to Analytics, but with the pairs in the state representing (count, targetUrl) instead of (count, shortUrl). Modify the incrementCountOnLookup sync to additionally do TargetAnalytics.incrementCount(targetUrl), using the targetUrl output of UrlShortening.lookup.
    - Generate short URLs that are not easily guessed: create a new concept SecureNonceGeneration for generating nonces that are harder to guess, and swap the call to NonceGeneration.generate for SecureNonceGeneration.generate.
    - Supporting reporting of analytics to creators of short URLs who have not registered as user: this feature is undesirable because ownership of the URL relies on having a User; without a registered user, there is no clear way to authenticate whether someone should be allowed to view analytics. Users should not be allowed to view analytics of a URL they did not create, as this may pose privacy and security risks. Having some other form of authentication such as secret tokens adds unnecessary complexity and may pose security risks.